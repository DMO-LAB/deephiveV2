{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from cec2017.functions import all_functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 96,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "The best position found is: [-29.3400947  -17.05551565]\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "array([200.00030463])"
      ]
     },
     "execution_count": 96,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "class PSOBSA:\n",
    "    def __init__(self, fitness_function, dimension, swarm_size, inertia_weight, \n",
    "                 acc_coefficients, mix_rate, mutation_probability, neighborhood_size,\n",
    "                 lower_bound=-100, upper_bound=100, scale = False):\n",
    "        self.fitness_function = fitness_function\n",
    "        self.dimension = dimension\n",
    "        self.swarm_size = swarm_size\n",
    "        self.inertia_weight = inertia_weight\n",
    "        self.acc_coefficients = acc_coefficients  # This is a tuple (c1, c2)\n",
    "        self.mix_rate = mix_rate\n",
    "        self.mutation_probability = mutation_probability\n",
    "        self.neighborhood_size = neighborhood_size\n",
    "        self.scale = scale\n",
    "        self.positions = np.random.uniform(low=lower_bound, high=upper_bound, size=(swarm_size, dimension))\n",
    "        if self.scale:\n",
    "            self.positions = self.scale(self.positions, lower_bound, upper_bound)\n",
    "        self.velocities = np.zeros((swarm_size, dimension))\n",
    "        self.pbest_positions = np.copy(self.positions)\n",
    "        self.fitness_values = self.fitness_function(self.unscale(self.positions, lower_bound, upper_bound)) if self.scale else self.fitness_function(self.positions)\n",
    "        self.gbest_position = self.positions[np.argmin(self.fitness_values)]\n",
    "        \n",
    "        if self.scale:\n",
    "            self.fitness_values = self.scale(self.fitness_values, min(self.fitness_values), max(self.fitness_values))\n",
    "    \n",
    "    def scale(self, position, lower_bound, upper_bound):\n",
    "        \"\"\" scale the position to the range [0, 1] \"\"\"\n",
    "        return (position - lower_bound) / (upper_bound - lower_bound)\n",
    "    \n",
    "    def unscale(self, position, lower_bound, upper_bound):\n",
    "        \"\"\" unscale the position from the range [0, 1] \"\"\"\n",
    "        return position * (upper_bound - lower_bound) + lower_bound\n",
    "    \n",
    "    def initialize_neighborhoods(self):\n",
    "        self.neighborhoods = []\n",
    "        for i in range(self.swarm_size):\n",
    "            neighborhood_indices = list(range(i - self.neighborhood_size, i)) + list(range(i + 1, i + 1 + self.neighborhood_size))\n",
    "            neighborhood_indices = [index % self.swarm_size for index in neighborhood_indices]  # Ensure indices are within bounds\n",
    "            self.neighborhoods.append(neighborhood_indices)\n",
    "    \n",
    "    def compute_lbest(self):\n",
    "        self.lbest_positions = np.zeros((self.swarm_size, self.dimension))\n",
    "        for i in range(self.swarm_size):\n",
    "            neighborhood_fitnesses = self.fitness_values[self.neighborhoods[i]]\n",
    "            best_neighbor_idx = self.neighborhoods[i][np.argmin(neighborhood_fitnesses)]\n",
    "            self.lbest_positions[i] = self.positions[best_neighbor_idx]\n",
    "    \n",
    "    def update_velocity(self):\n",
    "        r1, r2 = np.random.rand(self.swarm_size, self.dimension), np.random.rand(self.swarm_size, self.dimension)\n",
    "        cognitive_component = self.acc_coefficients[0] * r1 * (self.pbest_positions - self.positions)\n",
    "        social_component = self.acc_coefficients[1] * r2 * (self.gbest_position - self.positions)\n",
    "        self.velocities = self.inertia_weight * self.velocities + cognitive_component + social_component\n",
    "    \n",
    "    def update_positions(self):\n",
    "        self.positions += self.velocities\n",
    "        # Boundary conditions and velocity limits would be handled here\n",
    "\n",
    "    def calculate_fitness(self):\n",
    "        self.fitness_values = self.fitness_function(self.positions)\n",
    "        # Update pbest and gbest here\n",
    "\n",
    "    def mutate(self, positions, lbest_positions):\n",
    "        # Eq. (12) from the description:\n",
    "        # Tij = Xij + A(φ × Lbest - Xij)\n",
    "        A = 2 * np.random.rand(self.swarm_size, self.dimension)\n",
    "        phi = np.random.rand(self.swarm_size, self.dimension)\n",
    "        return positions + A * (phi * lbest_positions - positions)\n",
    "    \n",
    "    def crossover(self, positions, trial_positions):\n",
    "        # For each dimension, we have a mix rate chance of taking the value from the trial position\n",
    "        crossover_mask = np.random.rand(self.swarm_size, self.dimension) < self.mix_rate\n",
    "        new_positions = np.where(crossover_mask, trial_positions, positions)\n",
    "        return new_positions\n",
    "\n",
    "    # Placeholder for the main optimization loop\n",
    "    def optimize(self, iterations):\n",
    "        self.initialize_neighborhoods()\n",
    "        for _ in range(iterations):\n",
    "            self.compute_lbest()  # Compute Lbest positions\n",
    "            self.update_velocity()\n",
    "            self.update_positions()\n",
    "            self.calculate_fitness()\n",
    "            \n",
    "            # Mutation and Crossover\n",
    "            for i in range(self.swarm_size):\n",
    "                if np.random.rand() < self.mutation_probability:\n",
    "                    trial_positions = self.mutate(self.positions, self.lbest_positions)\n",
    "                else:\n",
    "                    self.permute_lbest(i)\n",
    "                    trial_positions = self.mutate(self.positions, self.lbest_positions[i])\n",
    "\n",
    "                new_positions = self.crossover(self.positions, trial_positions)\n",
    "                new_fitness = self.fitness_function(new_positions)\n",
    "\n",
    "                # Selection-II: Update the personal and global bests\n",
    "                better_mask = new_fitness < self.fitness_values\n",
    "                self.positions[better_mask] = new_positions[better_mask]\n",
    "                self.pbest_positions[better_mask] = new_positions[better_mask]\n",
    "                self.fitness_values[better_mask] = new_fitness[better_mask]\n",
    "\n",
    "                if np.min(new_fitness) < self.fitness_function(self.gbest_position.reshape(1, -1)):\n",
    "                    self.gbest_position = new_positions[np.argmin(new_fitness)]\n",
    "\n",
    "        return self.gbest_position\n",
    "    \n",
    "    def permute_lbest(self, particle_index):\n",
    "        # Apply a permutation to the lbest of the selected particle\n",
    "        # This is a simplification; in reality, you might want to shuffle the entire neighborhood\n",
    "        neighbor_indices = self.neighborhoods[particle_index]\n",
    "        np.random.shuffle(neighbor_indices)\n",
    "        self.lbest_positions[particle_index] = self.positions[neighbor_indices[0]]\n",
    "\n",
    "# Define a sample fitness function (e.g., Sphere function)\n",
    "def fitness_function(positions):\n",
    "    return all_functions[1](positions)\n",
    "\n",
    "# Initialize PSOBSA with a sample fitness function and parameters\n",
    "pso_bsa = PSOBSA(fitness_function=fitness_function,\n",
    "                  dimension=2,\n",
    "                  swarm_size=10,\n",
    "                  inertia_weight=0.7,\n",
    "                  acc_coefficients=(1.4, 1.4),\n",
    "                  mix_rate=0.5,\n",
    "                  mutation_probability=0.1,\n",
    "                  neighborhood_size=5)\n",
    "\n",
    "# Run the optimization\n",
    "best_position = pso_bsa.optimize(iterations=100)\n",
    "print(f\"The best position found is: {best_position}\")\n",
    "fitness_function(best_position.reshape(1, -1))\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 61,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([-12.8694118 ,  12.39274527])"
      ]
     },
     "execution_count": 61,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "pso_bsa.gbest_position"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "metadata": {},
   "outputs": [],
   "source": [
    "lbest = pso_bsa.lbest_positions\n",
    "# check the unique values in the lbest\n",
    "unique_lbest = np.unique(lbest, axis=0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 58,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "array([[-57.39223344,  -1.52898692],\n",
       "       [-20.73264993,  35.51276264],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692],\n",
       "       [-57.39223344,  -1.52898692]])"
      ]
     },
     "execution_count": 58,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "lbest"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "mlEnv",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
